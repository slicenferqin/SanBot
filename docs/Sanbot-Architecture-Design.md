# Sanbot 超级助理架构设计文档

**文档版本**: v1.0  
**创建日期**: 2026-02-02  
**作者**: Claude Opus 4.5  

---

## 命名释义

**Sanbot** — 取自老子《道德经》第四十二章：

> "道生一，一生二，二生三，三生万物。"

"三"在道家哲学中代表万物生成的临界点，是从简单到复杂、从有限到无限的转化枢纽。Sanbot 的命名寓意：

- **道生一**：基础设施层 — 系统的根基与本源
- **一生二**：认知层 — 记忆与推理的二元能力
- **二生三**：自主层 — 自我工具创建、自我改进、元认知监控三大突破
- **三生万物**：无限可能 — 从三层架构衍生出解决万千问题的能力

---

## 目录

1. [执行摘要](#执行摘要)
2. [设计哲学](#设计哲学)
3. [整体架构设计](#整体架构设计)
4. [基础设施层](#基础设施层)
5. [认知层](#认知层)
6. [自主层](#自主层)
7. [核心工作流程](#核心工作流程)
8. [安全与治理](#安全与治理)
9. [预期效果与成功指标](#预期效果与成功指标)
10. [实施路线图](#实施路线图)
11. [结语](#结语)

---

## 执行摘要

### 愿景

构建一个真正自主的超级助理：

> **"它自己思考、自己搜索、自己写工具、然后自己完成任务。它还能记住用户，建立持续的信任关系。"**

### 核心创新

Sanbot 不是简单的聊天机器人，也不是预定义工作流的执行器。它是一个具备**自主问题解决能力**的智能体，核心创新包括：

| 创新点 | 描述 | 价值 |
|--------|------|------|
| **Self-Tooling** | 动态创建所需工具 | 突破预定义工具的限制 |
| **递归自我改进** | 持续优化自身能力 | 越用越聪明 |
| **动态记忆召回** | 基于任务智能检索 | 精准的上下文增强 |
| **元认知监控** | 对自身推理的反思 | 更可靠的决策 |
| **上下文工程** | 智能管理有限窗口 | 处理复杂长任务 |
| **三层记忆架构** | 模拟人脑记忆系统 | 真正"记住"用户 |

### 设计原则

1. **自主优先**：能自己解决的问题，绝不询问用户
2. **本地优先**：用户数据本地存储，隐私至上
3. **渐进复杂**：从简单开始，按需增加复杂性
4. **安全内建**：安全不是附加功能，而是架构基因


---

## 设计哲学

### 从"工具调用"到"自主解决"

传统 AI Agent 的范式是：

```
用户请求 → Agent 分析 → 调用预定义工具 → 返回结果
```

这种模式的局限在于：
- **工具集固定**：只能做开发者预想的事情
- **被动响应**：等待用户明确指令
- **无记忆**：每次对话都是新的开始
- **无进化**：能力边界固定不变

Sanbot 的新范式是：

```
用户请求 → 自主思考 → 识别能力缺口 → 创建新工具 → 执行任务 → 自我改进 → 记忆沉淀
```

### 三层架构哲学

Sanbot 的架构设计遵循"道生一，一生二，二生三，三生万物"的哲学：

```
┌─────────────────────────────────────────────────────────────┐
│                        三层架构哲学                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  自主层 (三) - 突破与创新                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • Self-Tooling: 创造新能力                           │   │
│  │ • Self-Improvement: 持续进化                         │   │
│  │ • Meta-Cognition: 自我反思                           │   │
│  │                                                     │   │
│  │ 寓意：从有限到无限的跃迁                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↑                                  │
│  认知层 (二) - 记忆与推理                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • Memory System: 三层记忆架构                        │   │
│  │ • Reasoning Engine: 推理与规划                       │   │
│  │ • Context Engineering: 上下文管理                    │   │
│  │                                                     │   │
│  │ 寓意：阴阳二元，记忆与推理相辅相成                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↑                                  │
│  基础设施层 (一) - 根基与本源                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • Session Management: 会话隔离                       │   │
│  │ • Concurrency Control: 并发管理                      │   │
│  │ • Failover System: 容错机制                          │   │
│  │ • Tool Registry: 工具注册                            │   │
│  │                                                     │   │
│  │ 寓意：道之本源，万物之基                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心设计理念

#### 1. 自主性 (Autonomy)

**定义**：Agent 能够独立识别问题、规划方案、执行任务，无需用户微观管理。

**实现**：
- 任务分解与规划能力
- 工具缺口自动识别
- 动态工具创建与验证
- 自主错误恢复

#### 2. 记忆性 (Memory)

**定义**：Agent 能够记住用户偏好、历史交互、项目上下文，建立持续关系。

**实现**：
- 三层记忆架构 (L0/L1/L2)
- 三种召回时机 (会话初始化/推理前/动态)
- 记忆巩固机制
- 用户画像构建

#### 3. 进化性 (Evolution)

**定义**：Agent 能够从经验中学习，持续优化自身能力。

**实现**：
- 性能监控与分析
- 改进机会识别
- 改进方案生成与验证
- 安全的自我修改机制

#### 4. 可信性 (Trustworthiness)

**定义**：Agent 的行为可预测、可解释、可控制，用户可以信任它。

**实现**：
- 元认知监控（自我反思）
- 置信度评估
- 人工审核机制
- 完整的审计日志


---

## 整体架构设计

### 系统架构全景图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Sanbot 系统架构全景                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                          用户交互层                                    │ │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐         │ │
│  │  │  CLI    │ │  Web    │ │Telegram │ │ WeChat  │ │ Voice   │  ...    │ │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘         │ │
│  └───────┼──────────┼──────────┼──────────┼──────────┼───────────────────┘ │
│          │          │          │          │          │                     │
│          └──────────┴──────────┴──────────┴──────────┘                     │
│                                 │                                           │
│  ┌──────────────────────────────┼──────────────────────────────────────────┐│
│  │                              ▼              自主层                       ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Meta-Cognitive Monitor                          │ ││
│  │  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │ ││
│  │  │  │ 推理质量监控 │ │ 置信度评估  │ │  偏见检测   │ │  自我纠正   │  │ ││
│  │  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘  │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │                              │                                         ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Self-Tooling Engine                             │ ││
│  │  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │ ││
│  │  │  │ 能力缺口分析 │ │  工具生成   │ │  工具验证   │ │  工具沉淀   │  │ ││
│  │  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘  │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │                              │                                         ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Self-Improvement Engine                         │ ││
│  │  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │ ││
│  │  │  │  性能监控   │ │  改进识别   │ │  改进验证   │ │  安全回滚   │  │ ││
│  │  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘  │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                 │                                           │
│  ┌──────────────────────────────┼──────────────────────────────────────────┐│
│  │                              ▼              认知层                       ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Memory System (三层记忆)                        │ ││
│  │  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                │ ││
│  │  │  │     L0      │  │     L1      │  │     L2      │                │ ││
│  │  │  │  感觉记忆   │→│  短期记忆   │→│  长期记忆   │                │ ││
│  │  │  │ (当日对话)  │  │ (巩固记忆)  │  │ (抽象摘要)  │                │ ││
│  │  │  └─────────────┘  └─────────────┘  └─────────────┘                │ ││
│  │  │  • 三种召回时机  • Hybrid Search  • 记忆巩固机制                  │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │                              │                                         ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Reasoning Engine                                │ ││
│  │  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │ ││
│  │  │  │  任务规划   │ │  推理执行   │ │  CodeAct    │ │  结果验证   │  │ ││
│  │  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘  │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │                              │                                         ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Context Engineering Engine                      │ ││
│  │  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                  │ ││
│  │  │  │ 上下文精简  │ │ 上下文卸载  │ │ 上下文隔离  │                  │ ││
│  │  │  │ (Reduction) │ │ (Offloading)│ │ (Isolation) │                  │ ││
│  │  │  └─────────────┘ └─────────────┘ └─────────────┘                  │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                 │                                           │
│  ┌──────────────────────────────┼──────────────────────────────────────────┐│
│  │                              ▼           基础设施层                      ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Session Manager                                 │ ││
│  │  │  • Session-Based Identity  • 多租户隔离  • 会话持久化              │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Concurrency Controller                          │ ││
│  │  │  • Lane System  • 优先级队列  • 资源限制  • 死锁预防               │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Failover Manager                                │ ││
│  │  │  • Auth轮换  • Model Fallback  • Context Compaction  • 降级策略   │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  │  ┌───────────────────────────────────────────────────────────────────┐ ││
│  │  │                    Tool Registry                                   │ ││
│  │  │  • 静态工具  • 动态工具  • 工具策略  • 沙箱执行                   │ ││
│  │  └───────────────────────────────────────────────────────────────────┘ ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 数据流架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Sanbot 数据流架构                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  用户输入                                                                   │
│      │                                                                      │
│      ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. 会话初始化召回 (Session Start Recall)                            │   │
│  │    • 加载用户画像                                                    │   │
│  │    • 加载项目上下文                                                  │   │
│  │    • 加载近期对话摘要                                                │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 2. 推理前召回 (Pre-Inference Recall)                                │   │
│  │    • 分析用户意图                                                    │   │
│  │    • 语义检索相关记忆                                                │   │
│  │    • 增强上下文                                                      │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 3. 任务规划与工具检查                                               │   │
│  │    • 分解子任务                                                      │   │
│  │    • 识别所需能力                                                    │   │
│  │    • 检查工具缺口 ──────────────────┐                               │   │
│  └────────────────────────────────┬────┼───────────────────────────────┘   │
│                                   │    │                                    │
│                                   │    ▼                                    │
│                                   │  ┌─────────────────────────────────┐   │
│                                   │  │ Self-Tooling (如有缺口)         │   │
│                                   │  │  • 生成工具代码                 │   │
│                                   │  │  • 验证工具                     │   │
│                                   │  │  • 注册工具                     │   │
│                                   │  └────────────────┬────────────────┘   │
│                                   │                   │                     │
│                                   ▼◄──────────────────┘                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 4. 执行循环                                                         │   │
│  │    ┌─────────────────────────────────────────────────────────────┐  │   │
│  │    │ 4.1 选择行动 → 4.2 执行 → 4.3 元认知监控 → 4.4 动态召回     │  │   │
│  │    │      ↑                                              │        │  │   │
│  │    │      └──────────────── 未完成 ◄─────────────────────┘        │  │   │
│  │    └─────────────────────────────────────────────────────────────┘  │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 5. 结果验证与输出                                                   │   │
│  │    • 检查结果正确性                                                  │   │
│  │    • 生成用户友好的响应                                              │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 6. 记忆沉淀 (后台)                                                  │   │
│  │    • 保存对话到 L0                                                   │   │
│  │    • 触发记忆巩固 (L0→L1→L2)                                        │   │
│  │    • 更新用户画像                                                    │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 7. 自我改进 (后台异步)                                              │   │
│  │    • 分析本次执行效果                                                │   │
│  │    • 识别改进机会                                                    │   │
│  │    • 验证并应用改进                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```


---

## 基础设施层

基础设施层是 Sanbot 的根基，借鉴 OpenClaw 的成熟实践，提供稳定可靠的底层支撑。

### 4.1 Session Manager (会话管理器)

#### 设计目标

- **多租户隔离**：不同用户、不同项目的数据完全隔离
- **状态持久化**：会话状态可恢复，支持断点续传
- **身份追踪**：完整的会话生命周期追踪

#### 核心设计

```typescript
interface SessionManager {
  // 会话标识：agent:{agentId}:{context}
  sessionId: string
  
  // 会话状态
  state: {
    userId: string
    projectId?: string
    startTime: Date
    lastActiveTime: Date
    messageCount: number
    toolCallCount: number
  }
  
  // 会话上下文
  context: {
    systemPrompt: string
    userProfile: UserProfile
    projectContext?: ProjectContext
    conversationHistory: Message[]
  }
  
  // 生命周期方法
  create(config: SessionConfig): Session
  restore(sessionId: string): Session
  persist(session: Session): void
  terminate(sessionId: string): void
}
```

#### 会话隔离策略

```
┌─────────────────────────────────────────────────────────────┐
│                    会话隔离架构                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  用户A                          用户B                       │
│    │                              │                         │
│    ▼                              ▼                         │
│  ┌─────────────┐              ┌─────────────┐              │
│  │ Session A1  │              │ Session B1  │              │
│  │ (项目X)     │              │ (项目Y)     │              │
│  │ ┌─────────┐ │              │ ┌─────────┐ │              │
│  │ │ Memory  │ │              │ │ Memory  │ │              │
│  │ │ Tools   │ │              │ │ Tools   │ │              │
│  │ │ Context │ │              │ │ Context │ │              │
│  │ └─────────┘ │              │ └─────────┘ │              │
│  └─────────────┘              └─────────────┘              │
│         │                            │                      │
│         ▼                            ▼                      │
│  ┌─────────────┐              ┌─────────────┐              │
│  │ Session A2  │              │ Session B2  │              │
│  │ (项目Z)     │              │ (项目X)     │              │
│  └─────────────┘              └─────────────┘              │
│                                                             │
│  数据隔离保证：                                             │
│  • 用户A无法访问用户B的任何数据                            │
│  • 同一用户的不同项目会话相互独立                          │
│  • 会话间的工具调用结果不会泄露                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 Concurrency Controller (并发控制器)

#### 设计目标

- **防止任务饥饿**：高优先级任务不被阻塞
- **资源公平分配**：不同类型任务使用独立资源
- **死锁预防**：层次化的执行顺序控制

#### Lane System (泳道系统)

```
┌─────────────────────────────────────────────────────────────┐
│                    Lane System 设计                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Main Lane (主泳道)                    优先级: 最高   │   │
│  │ • 用户直接交互                                       │   │
│  │ • 实时响应要求                                       │   │
│  │ • 并发限制: 1                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Subagent Lane (子代理泳道)            优先级: 高     │   │
│  │ • 后台子任务执行                                     │   │
│  │ • 可并行多个子代理                                   │   │
│  │ • 并发限制: 3                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Cron Lane (定时任务泳道)              优先级: 中     │   │
│  │ • 定时触发的任务                                     │   │
│  │ • 记忆巩固、自我改进等                               │   │
│  │ • 并发限制: 2                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Background Lane (后台泳道)            优先级: 低     │   │
│  │ • 非紧急的后台处理                                   │   │
│  │ • 日志分析、统计计算等                               │   │
│  │ • 并发限制: 1                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  调度策略：                                                 │
│  1. Main Lane 任务立即执行，可抢占其他泳道资源             │
│  2. 同泳道内 FIFO 排队                                     │
│  3. 跨泳道按优先级调度                                     │
│  4. 支持任务超时和取消                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.3 Failover Manager (容错管理器)

#### 设计目标

- **高可用性**：单点故障不影响整体服务
- **优雅降级**：在资源受限时保持核心功能
- **自动恢复**：故障后自动尝试恢复

#### 四级容错机制

```
┌─────────────────────────────────────────────────────────────┐
│                    四级容错机制                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Level 1: Auth Profile 轮换                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ API Key 1 失败 → API Key 2 → API Key 3 → ...        │   │
│  │ • 自动检测 API 限流/失效                            │   │
│  │ • 无缝切换到备用凭证                                │   │
│  │ • 支持多 Provider (OpenAI/Anthropic/Google)         │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼ 全部失败                         │
│  Level 2: Model Fallback                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Claude Opus → Claude Sonnet → GPT-4 → GPT-3.5       │   │
│  │ • 按能力降级选择模型                                │   │
│  │ • 保持任务可完成性                                  │   │
│  │ • 记录降级事件供后续分析                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼ 上下文过长                       │
│  Level 3: Context Compaction                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 完整上下文 → 摘要上下文 → 最小上下文                │   │
│  │ • 智能压缩对话历史                                  │   │
│  │ • 保留关键信息                                      │   │
│  │ • 卸载非必要内容到外部存储                          │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼ 仍然失败                         │
│  Level 4: Thinking Mode 降级                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Extended Thinking → Standard → Minimal              │   │
│  │ • 减少推理深度换取响应                              │   │
│  │ • 标记为降级响应                                    │   │
│  │ • 建议用户简化任务                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.4 Tool Registry (工具注册中心)

#### 设计目标

- **CLI-first**：所有工具都是可执行的 CLI 命令
- **统一管理**：静态工具和动态工具统一注册
- **确认 + 审计**：用危险操作确认和完整审计日志替代沙箱

#### 设计哲学

借鉴 OpenClaw 的核心理念：**CLI 是最通用的"协议"**。

- 任何语言都能写 CLI 工具
- 任何语言都能调用 CLI 工具
- 不需要专门的协议层（如 MCP）
- 天然可组合（管道、重定向）
- 调试简单（直接在终端测试）

#### 核心工具：exec

`exec` 是 Sanbot 能力扩展的基础。有了它，Agent 可以：
- 执行任意 shell 命令
- 调用系统工具
- 运行自己创建的 CLI 工具
- 组合多个命令完成复杂任务

```
┌─────────────────────────────────────────────────────────────┐
│                    exec 工具的核心地位                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  exec ──► 执行任意 shell 命令                                │
│    │                                                        │
│    ├──► 调用系统工具 (git, curl, jq, awk, ...)              │
│    │                                                        │
│    ├──► 运行 Self-Tooling 创建的 CLI 工具                   │
│    │    ~/.sanbot/tools/csv_parse                           │
│    │    ~/.sanbot/tools/trend_analysis                      │
│    │                                                        │
│    └──► 组合命令 (管道、重定向、条件执行)                    │
│         cat data.csv | ./csv_parse | ./trend_analysis       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 工具分类

```typescript
interface ToolRegistry {
  // 核心工具：exec 是一切能力的基础
  coreTools: {
    exec: 'shell command execution'  // 能力扩展的根基
  }

  // 内置工具：常用操作的便捷封装（底层都是 exec）
  builtinTools: {
    file: ['read', 'write', 'list', 'search']
    web: ['fetch', 'search']
    memory: ['store', 'recall', 'forget']
  }

  // 动态工具：Self-Tooling 创建的 CLI 脚本
  dynamicTools: {
    location: '~/.sanbot/tools/'
    format: 'executable CLI scripts'
    languages: 'any (bash, python, node, ...)'
  }

  // 安全策略（确认 + 审计，无沙箱）
  policies: {
    requireApproval: string[]      // 需要用户确认的操作类型
    auditLog: true                 // 完整审计日志
    rateLimit: Map<string, number> // 调用频率限制
    disabled: string[]             // 禁用的工具
  }
}
```

#### 为什么不用沙箱？

```
┌─────────────────────────────────────────────────────────────┐
│                    沙箱的虚假安全感                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  问题：Agent 本身就有 exec 权限                              │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 如果 Agent 想执行危险操作：                          │   │
│  │                                                     │   │
│  │ 方式 A: 调用 Self-Tooling 创建的工具 ──► 被沙箱拦截  │   │
│  │ 方式 B: 直接用 exec 执行命令 ──► 沙箱管不到          │   │
│  │                                                     │   │
│  │ 结论：沙箱只保护"工具"，不保护"exec"，是假安全      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  真正的安全来自：                                            │
│  • Agent 的对齐（它不会生成恶意代码）                        │
│  • 用户的确认（危险操作需要批准）                            │
│  • 完整的审计（所有操作可追溯）                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```


---

## 认知层

认知层是 Sanbot 的"大脑"，负责记忆、推理和上下文管理。这一层的设计融合了脑科学理论和工程最佳实践。

### 5.1 Memory System (三层记忆系统)

#### 设计理念

Sanbot 的记忆系统基于神经科学的**海马体-皮层记忆巩固模型**：

```
┌─────────────────────────────────────────────────────────────┐
│              海马体-皮层记忆巩固模型                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  感觉输入 ──► 海马体 (快速编码) ──► 皮层 (长期存储)          │
│              │                      │                       │
│              │ 睡眠重放              │ 抽象泛化               │
│              │ (Sleep Replay)       │ (Abstraction)         │
│              ▼                      ▼                       │
│         短期记忆                 长期记忆                    │
│         (情景性)                 (语义性)                    │
│                                                             │
│  对应到 Sanbot:                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │     L0      │  │     L1      │  │     L2      │         │
│  │  感觉记忆   │→│  短期记忆   │→│  长期记忆   │         │
│  │ daily/*.md  │  │long_term/*.md│ │ *-summary.md│         │
│  │ (当日对话)  │  │ (巩固记忆)  │  │ (抽象摘要)  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 三层记忆架构

```typescript
interface MemorySystem {
  // L0: 感觉记忆 (Sensory Memory)
  L0: {
    storage: 'daily/{date}.md'
    retention: '24 hours'
    content: 'raw conversation logs'
    indexing: 'none (sequential access)'
  }
  
  // L1: 短期记忆 (Short-term Memory)
  L1: {
    storage: 'long_term/{topic}.md'
    retention: '30 days (with decay)'
    content: 'consolidated memories'
    indexing: 'vector + full-text'
  }
  
  // L2: 长期记忆 (Long-term Memory)
  L2: {
    storage: '{category}-summary.md'
    retention: 'permanent'
    content: 'abstracted knowledge'
    indexing: 'semantic categories'
  }
}
```

#### 记忆巩固机制

```
┌─────────────────────────────────────────────────────────────┐
│                    记忆巩固流程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  L0 (当日对话)                                              │
│      │                                                      │
│      │ 触发条件：                                           │
│      │ • 每日定时 (凌晨)                                    │
│      │ • 对话结束后                                         │
│      │ • 手动触发                                           │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 巩固处理器                                           │   │
│  │ 1. 提取关键信息                                      │   │
│  │ 2. 识别重要事实/偏好/决策                            │   │
│  │ 3. 去除冗余和噪音                                    │   │
│  │ 4. 生成结构化记忆条目                                │   │
│  └────────────────────────────────┬────────────────────┘   │
│                                   │                         │
│                                   ▼                         │
│  L1 (巩固记忆)                                              │
│      │                                                      │
│      │ 触发条件：                                           │
│      │ • 记忆条目达到阈值                                   │
│      │ • 周期性摘要 (每周)                                  │
│      │ • 主题聚类完成                                       │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 抽象处理器                                           │   │
│  │ 1. 聚类相关记忆                                      │   │
│  │ 2. 提取共性模式                                      │   │
│  │ 3. 生成高层摘要                                      │   │
│  │ 4. 建立知识图谱连接                                  │   │
│  └────────────────────────────────┬────────────────────┘   │
│                                   │                         │
│                                   ▼                         │
│  L2 (长期记忆)                                              │
│  • 用户画像摘要                                             │
│  • 项目知识摘要                                             │
│  • 领域专业知识                                             │
│  • 偏好和习惯模式                                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 三种召回时机

```typescript
enum RecallTiming {
  SESSION_START,    // 会话初始化时
  PRE_INFERENCE,    // 推理前
  DYNAMIC           // 动态按需
}

interface RecallStrategy {
  // 1. Session Start Recall (会话初始化召回)
  sessionStart: {
    trigger: 'new session created'
    retrieve: ['user_profile', 'recent_summary', 'project_context']
    inject: 'system prompt'
    purpose: '从第一条消息就"认识"用户'
  }
  
  // 2. Pre-Inference Recall (推理前召回)
  preInference: {
    trigger: 'user message received'
    retrieve: ['semantic_search(message)', 'entity_related_memories']
    inject: 'context augmentation'
    purpose: '针对性检索，减少噪音'
  }
  
  // 3. Dynamic Recall (动态召回)
  dynamic: {
    trigger: 'agent determines need'
    retrieve: ['on_demand_search']
    inject: 'mid-reasoning context'
    purpose: 'Agent自主决定何时需要更多信息'
  }
}
```

#### Hybrid Search (混合检索)

```
┌─────────────────────────────────────────────────────────────┐
│                    Hybrid Search 架构                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  查询输入                                                   │
│      │                                                      │
│      ├──────────────────┬──────────────────┐               │
│      ▼                  ▼                  ▼               │
│  ┌────────┐        ┌────────┐        ┌────────┐           │
│  │ Vector │        │  BM25  │        │ Exact  │           │
│  │ Search │        │ Search │        │ Match  │           │
│  └───┬────┘        └───┬────┘        └───┬────┘           │
│      │                 │                 │                 │
│      │ 语义相似度       │ 关键词匹配       │ 精确匹配        │
│      │                 │                 │                 │
│      └────────────────┬┴─────────────────┘                 │
│                       │                                     │
│                       ▼                                     │
│              ┌─────────────────┐                           │
│              │   RRF Fusion    │                           │
│              │ (Reciprocal    │                           │
│              │  Rank Fusion)  │                           │
│              └────────┬────────┘                           │
│                       │                                     │
│                       ▼                                     │
│              ┌─────────────────┐                           │
│              │  Reranking     │                           │
│              │  (可选)        │                           │
│              └────────┬────────┘                           │
│                       │                                     │
│                       ▼                                     │
│                  排序后的结果                               │
│                                                             │
│  RRF 公式: score = Σ 1/(k + rank_i)                        │
│  k = 60 (常用值)                                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Reasoning Engine (推理引擎)

#### 设计目标

- **任务分解**：将复杂任务分解为可执行的子任务
- **策略选择**：根据任务类型选择最优执行策略
- **结果验证**：确保执行结果符合预期

#### 推理模式

```typescript
interface ReasoningEngine {
  // 推理模式
  modes: {
    // 直接执行：简单任务，无需规划
    direct: {
      trigger: 'simple, single-step task'
      process: 'analyze → execute → respond'
    }
    
    // 规划执行：复杂任务，需要分解
    planned: {
      trigger: 'complex, multi-step task'
      process: 'analyze → plan → execute_steps → synthesize → respond'
    }
    
    // 迭代优化：需要多轮改进的任务
    iterative: {
      trigger: 'quality-sensitive task'
      process: 'generate → evaluate → improve → repeat'
    }
    
    // 协作执行：需要多个专家的任务
    collaborative: {
      trigger: 'multi-domain task'
      process: 'route → delegate → collect → synthesize'
    }
  }
  
  // 推理方法
  analyze(task: Task): TaskAnalysis
  plan(analysis: TaskAnalysis): ExecutionPlan
  execute(plan: ExecutionPlan): ExecutionResult
  verify(result: ExecutionResult): VerificationResult
}
```

#### CodeAct 执行范式

Sanbot 支持 CodeAct 执行范式，用代码替代 JSON 工具调用：

```
┌─────────────────────────────────────────────────────────────┐
│              CodeAct vs JSON Tool Call                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  传统 JSON Tool Call:                                       │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ {                                                    │   │
│  │   "tool": "web_search",                             │   │
│  │   "arguments": { "query": "latest AI news" }        │   │
│  │ }                                                    │   │
│  │ // 等待结果...                                       │   │
│  │ {                                                    │   │
│  │   "tool": "filter_results",                         │   │
│  │   "arguments": { "date_after": "2024-01-01" }       │   │
│  │ }                                                    │   │
│  │ // 等待结果...                                       │   │
│  │ // 需要多轮对话完成复杂逻辑                          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  CodeAct 范式:                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ```python                                            │   │
│  │ results = web_search("latest AI news")              │   │
│  │ filtered = [r for r in results                      │   │
│  │             if r.date > "2024-01-01"]               │   │
│  │ summary = summarize(filtered)                       │   │
│  │ save_to_memory(summary, tags=["AI", "news"])        │   │
│  │ return summary                                       │   │
│  │ ```                                                  │   │
│  │ // 单次生成，完整逻辑                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  CodeAct 优势:                                              │
│  • 更强的表达能力 (循环、条件、变量)                       │
│  • 更好的组合性 (函数调用链)                               │
│  • 更自然的错误处理 (try-except)                           │
│  • 更容易调试和理解                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.3 Context Engineering Engine (上下文工程引擎)

#### 设计理念

从 **Prompt Engineering** 到 **Context Engineering** 的范式转变：

> "上下文不是提示词的附属品，而是 Agent 能力的核心架构原语。"

#### 三大策略

```
┌─────────────────────────────────────────────────────────────┐
│              Context Engineering 三策略                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  策略1: Context Reduction (上下文精简)                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 原始内容 (10KB) ──► 摘要/预览 (1KB)                  │   │
│  │                                                     │   │
│  │ 技术手段:                                           │   │
│  │ • 对话历史摘要                                      │   │
│  │ • 文件内容预览 (首尾 + 关键段落)                    │   │
│  │ • 工具结果精简                                      │   │
│  │ • 冗余信息删除                                      │   │
│  │                                                     │   │
│  │ 效果: 节省 70-90% tokens                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  策略2: Context Offloading (上下文卸载)                     │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 长内容 ──► 写入外部存储 ──► 保留引用                │   │
│  │                                                     │   │
│  │ 技术手段:                                           │   │
│  │ • 大文件写入临时存储，保留路径引用                  │   │
│  │ • 中间结果存入记忆系统，按需召回                    │   │
│  │ • 代码块存入文件，保留摘要描述                      │   │
│  │                                                     │   │
│  │ 效果: 支持处理任意长度的内容                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  策略3: Context Isolation (上下文隔离)                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 复杂任务 ──► 子Agent处理 ──► 返回结果摘要           │   │
│  │                                                     │   │
│  │ 技术手段:                                           │   │
│  │ • 子任务委托给独立子Agent                           │   │
│  │ • 子Agent有独立的上下文窗口                         │   │
│  │ • 只返回结果摘要给主Agent                           │   │
│  │                                                     │   │
│  │ 效果: 并行处理 + 上下文隔离                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```


---

## 自主层

自主层是 Sanbot 的核心创新，实现了从"被动工具调用"到"主动问题解决"的跃迁。

### 6.1 Self-Tooling Engine (自主工具引擎)

#### 核心理念

> "当现有工具无法满足需求时，Agent 应该能够创造新工具。"

传统 Agent 受限于预定义的工具集，而 Self-Tooling 让 Sanbot 能够：
- 识别能力缺口
- 动态生成新工具
- 验证工具正确性
- 沉淀可复用工具

#### 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                Self-Tooling 工作流程 (CLI-first)             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 任务分析                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 用户任务 ──► 分析所需能力 ──► 检查现有工具          │   │
│  │                                                     │   │
│  │ 示例:                                               │   │
│  │ 任务: "帮我分析这个 CSV 文件的销售趋势"             │   │
│  │ 所需能力: [CSV解析, 数据分析, 趋势计算, 可视化]     │   │
│  │ 现有工具: [file_read, awk, jq, ...]                 │   │
│  │ 缺口: [csv_parse, trend_analysis]                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  2. 工具规格生成                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 为每个缺口生成 CLI 工具规格:                        │   │
│  │                                                     │   │
│  │ {                                                   │   │
│  │   name: "csv_parse",                               │   │
│  │   description: "解析CSV文件并输出JSON",            │   │
│  │   usage: "csv_parse <file> [--delimiter=,]",       │   │
│  │   input: "file path or stdin",                     │   │
│  │   output: "JSON to stdout"                         │   │
│  │ }                                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  3. CLI 脚本生成                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ #!/usr/bin/env python3                             │   │
│  │ # ~/.sanbot/tools/csv_parse                        │   │
│  │ import csv, json, sys, argparse                    │   │
│  │                                                     │   │
│  │ parser = argparse.ArgumentParser()                 │   │
│  │ parser.add_argument('file', nargs='?')             │   │
│  │ parser.add_argument('--delimiter', default=',')    │   │
│  │ args = parser.parse_args()                         │   │
│  │                                                     │   │
│  │ input_stream = open(args.file) if args.file \      │   │
│  │                else sys.stdin                       │   │
│  │ reader = csv.DictReader(input_stream,              │   │
│  │                         delimiter=args.delimiter)   │   │
│  │ print(json.dumps(list(reader)))                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  4. 工具验证                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 验证步骤:                                           │   │
│  │ ✓ 语法检查 (python -m py_compile / shellcheck)     │   │
│  │ ✓ 执行测试 (用样例数据测试)                        │   │
│  │ ✓ 输出验证 (检查输出格式是否符合预期)              │   │
│  │ ✓ 设置可执行权限 (chmod +x)                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  5. 工具注册与沉淀                                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 保存到 ~/.sanbot/tools/                          │   │
│  │ • 记录到记忆系统 (工具创建事件)                     │   │
│  │ • 可选：展示给用户审核                              │   │
│  │ • 统计使用情况，定期清理不用的工具                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  使用示例:                                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ # 直接调用                                          │   │
│  │ ~/.sanbot/tools/csv_parse sales.csv                 │   │
│  │                                                     │   │
│  │ # 管道组合                                          │   │
│  │ cat sales.csv | csv_parse | trend_analysis          │   │
│  │                                                     │   │
│  │ # 与系统工具组合                                    │   │
│  │ csv_parse sales.csv | jq '.[] | select(.amount>100)'│   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 安全策略：确认 + 审计

```typescript
interface SelfToolingSecurity {
  // 代码审查（可选）
  codeReview: {
    showToUser: true,             // 新工具代码展示给用户
    autoApprove: {
      conditions: [
        'similar_tool_exists',    // 类似工具已存在
        'read_only_operations',   // 只读操作
        'user_trust_level_high'   // 用户信任等级高
      ]
    }
  }

  // 危险操作确认
  dangerousOperations: {
    requireConfirmation: [
      'file_delete',              // 删除文件
      'file_write_system',        // 写入系统目录
      'network_external',         // 外部网络请求
      'process_kill',             // 终止进程
      'permission_change'         // 修改权限
    ]
  }

  // 完整审计日志
  auditLog: {
    location: '~/.sanbot/logs/audit.log'
    content: [
      'tool_creation',            // 工具创建记录
      'tool_execution',           // 工具执行记录
      'command_executed',         // 执行的命令
      'input_output',             // 输入输出
      'timestamp',                // 时间戳
      'context'                   // 上下文信息
    ]
    retention: '30 days'
  }
}
```

### 6.2 Self-Improvement Engine (自我改进引擎)

#### 核心理念

> "Agent 应该能够从经验中学习，持续优化自身能力。"

这是 Gödel Agent 思想的实践：Agent 可以修改自己的策略、提示词、甚至部分逻辑。

#### 可改进的维度

```
┌─────────────────────────────────────────────────────────────┐
│                可改进维度与风险等级                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  维度                    示例                    风险等级   │
│  ─────────────────────────────────────────────────────────  │
│  提示词模板              优化系统提示词            低       │
│                          改进工具描述                       │
│                          调整输出格式                       │
│  ─────────────────────────────────────────────────────────  │
│  推理策略                调整思考深度              中       │
│                          优化规划方式                       │
│                          改进错误恢复策略                   │
│  ─────────────────────────────────────────────────────────  │
│  工具选择                优化工具调用顺序          中       │
│                          改进工具组合策略                   │
│                          调整工具参数默认值                 │
│  ─────────────────────────────────────────────────────────  │
│  记忆策略                调整召回时机              中       │
│                          优化检索参数                       │
│                          改进巩固规则                       │
│  ─────────────────────────────────────────────────────────  │
│  核心逻辑                修改决策算法              高       │
│                          改变执行流程                       │
│                          调整安全策略                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 自我改进循环

```
┌─────────────────────────────────────────────────────────────┐
│                    自我改进循环                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                                                     │   │
│  │  执行任务 ──► 收集指标 ──► 分析表现                 │   │
│  │      ▲                          │                   │   │
│  │      │                          ▼                   │   │
│  │      │                    识别改进机会              │   │
│  │      │                          │                   │   │
│  │      │                          ▼                   │   │
│  │      │                    生成改进方案              │   │
│  │      │                          │                   │   │
│  │      │                          ▼                   │   │
│  │      │                    沙箱验证改进              │   │
│  │      │                          │                   │   │
│  │      │              ┌───────────┴───────────┐      │   │
│  │      │              ▼                       ▼      │   │
│  │      │         验证通过                验证失败    │   │
│  │      │              │                       │      │   │
│  │      │              ▼                       ▼      │   │
│  │      │         应用改进                记录失败    │   │
│  │      │              │                       │      │   │
│  │      │              ▼                       │      │   │
│  │      │         监控效果                     │      │   │
│  │      │              │                       │      │   │
│  │      │      ┌───────┴───────┐              │      │   │
│  │      │      ▼               ▼              │      │   │
│  │      │   效果正向       效果负向           │      │   │
│  │      │      │               │              │      │   │
│  │      │      ▼               ▼              │      │   │
│  │      │   保留改进        回滚改进          │      │   │
│  │      │      │               │              │      │   │
│  │      └──────┴───────────────┴──────────────┘      │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  关键约束:                                                  │
│  • 改进必须可验证 (有明确的成功指标)                       │
│  • 保持核心目标不变 (不能修改安全策略)                     │
│  • 支持完整回滚 (任何改进都可撤销)                         │
│  • 人工审核高风险改进                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.3 Meta-Cognitive Monitor (元认知监控器)

#### 核心理念

> "Agent 不仅要思考问题，还要思考自己是如何思考的。"

元认知是人类智能的重要特征，让 Sanbot 具备自我反思能力。

#### 四个监控维度

```
┌─────────────────────────────────────────────────────────────┐
│                    元认知四维度                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 知识监控 (Knowledge Monitoring)                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 核心问题:                                           │   │
│  │ • 我知道什么？                                      │   │
│  │ • 我不知道什么？                                    │   │
│  │ • 我的知识可靠吗？                                  │   │
│  │                                                     │   │
│  │ 实现:                                               │   │
│  │ • 知识边界检测                                      │   │
│  │ • 信息来源追踪                                      │   │
│  │ • 知识时效性检查                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  2. 过程监控 (Process Monitoring)                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 核心问题:                                           │   │
│  │ • 我的推理步骤正确吗？                              │   │
│  │ • 我是否遗漏了重要因素？                            │   │
│  │ • 我的方法是否最优？                                │   │
│  │                                                     │   │
│  │ 实现:                                               │   │
│  │ • 推理链路追踪                                      │   │
│  │ • 逻辑一致性检查                                    │   │
│  │ • 替代方案评估                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  3. 结果监控 (Result Monitoring)                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 核心问题:                                           │   │
│  │ • 我的结论合理吗？                                  │   │
│  │ • 我的置信度是否过高/过低？                         │   │
│  │ • 结论是否与已知事实一致？                          │   │
│  │                                                     │   │
│  │ 实现:                                               │   │
│  │ • 结果合理性检查                                    │   │
│  │ • 置信度校准                                        │   │
│  │ • 事实一致性验证                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  4. 策略监控 (Strategy Monitoring)                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 核心问题:                                           │   │
│  │ • 我选择的策略是否合适？                            │   │
│  │ • 是否需要切换策略？                                │   │
│  │ • 如何改进未来的策略选择？                          │   │
│  │                                                     │   │
│  │ 实现:                                               │   │
│  │ • 策略效果评估                                      │   │
│  │ • 动态策略调整                                      │   │
│  │ • 策略学习与优化                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 自我纠正机制

```typescript
interface SelfCorrection {
  // 问题类型与纠正策略
  corrections: {
    low_confidence: {
      detection: 'confidence < 0.7',
      action: 'seek_more_information',
      implementation: 'trigger dynamic recall or web search'
    },
    
    potential_bias: {
      detection: 'bias_detector.score > 0.5',
      action: 'reevaluate_from_alternative_perspective',
      implementation: 'generate counter-arguments, re-analyze'
    },
    
    logical_error: {
      detection: 'logic_checker.found_inconsistency',
      action: 'correct_reasoning_chain',
      implementation: 'identify error point, regenerate from there'
    },
    
    missing_consideration: {
      detection: 'completeness_checker.gaps.length > 0',
      action: 'add_missing_factors',
      implementation: 'expand analysis scope, include missing aspects'
    }
  }
}
```


---

## 核心工作流程

### 完整的任务处理流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Sanbot 核心工作流程                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  用户: "帮我分析最近一个月的销售数据，找出增长最快的产品类别"               │
│      │                                                                      │
│      ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 1: 会话初始化                                                 │   │
│  │                                                                     │   │
│  │ Session Start Recall:                                               │   │
│  │ • 加载用户画像: "数据分析师，偏好可视化，常用 Python"               │   │
│  │ • 加载项目上下文: "电商平台，销售数据在 /data/sales/"              │   │
│  │ • 加载近期对话: "上周讨论过季度报告格式"                           │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 2: 任务理解                                                   │   │
│  │                                                                     │   │
│  │ Pre-Inference Recall:                                               │   │
│  │ • 语义检索: "销售分析" → 找到历史分析方法记忆                      │   │
│  │ • 实体识别: "一个月", "产品类别", "增长"                           │   │
│  │                                                                     │   │
│  │ 任务分析:                                                           │   │
│  │ • 意图: 数据分析 + 趋势识别                                        │   │
│  │ • 复杂度: 中等 (多步骤，需要数据处理)                              │   │
│  │ • 所需能力: [文件读取, CSV解析, 数据聚合, 趋势计算, 排序]          │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 3: 任务规划                                                   │   │
│  │                                                                     │   │
│  │ 执行计划:                                                           │   │
│  │ 1. 定位销售数据文件                                                 │   │
│  │ 2. 读取并解析 CSV 数据                                              │   │
│  │ 3. 筛选最近一个月的数据                                             │   │
│  │ 4. 按产品类别聚合销售额                                             │   │
│  │ 5. 计算各类别的增长率                                               │   │
│  │ 6. 排序找出增长最快的类别                                           │   │
│  │ 7. 生成分析报告                                                     │   │
│  │                                                                     │   │
│  │ 工具检查:                                                           │   │
│  │ • 现有: [file_read, file_list]                                     │   │
│  │ • 缺口: [csv_parse, data_aggregate, growth_calculate]              │   │
│  │ • 决策: 触发 Self-Tooling                                          │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 4: Self-Tooling (工具创建)                                    │   │
│  │                                                                     │   │
│  │ 创建工具 1: csv_parse                                               │   │
│  │ • 生成代码 → 静态分析 → 测试验证 → 注册                            │   │
│  │                                                                     │   │
│  │ 创建工具 2: data_aggregate                                          │   │
│  │ • 生成代码 → 静态分析 → 测试验证 → 注册                            │   │
│  │                                                                     │   │
│  │ 创建工具 3: growth_calculate                                        │   │
│  │ • 生成代码 → 静态分析 → 测试验证 → 注册                            │   │
│  │                                                                     │   │
│  │ 状态: 3个新工具创建成功，已注册到 Tool Registry                    │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 5: 执行循环                                                   │   │
│  │                                                                     │   │
│  │ Step 1: file_list("/data/sales/")                                  │   │
│  │ → 找到 sales_2024.csv                                              │   │
│  │                                                                     │   │
│  │ Step 2: file_read("/data/sales/sales_2024.csv")                    │   │
│  │ → 读取原始数据                                                      │   │
│  │                                                                     │   │
│  │ Step 3: csv_parse(data)                                            │   │
│  │ → 解析为结构化数据 (12,450 条记录)                                 │   │
│  │                                                                     │   │
│  │ 元认知检查: 数据量较大，置信度 0.85，继续执行                      │   │
│  │                                                                     │   │
│  │ Step 4: filter_by_date(data, "last_month")                         │   │
│  │ → 筛选出 3,200 条记录                                              │   │
│  │                                                                     │   │
│  │ Step 5: data_aggregate(filtered, "category", "sum:amount")         │   │
│  │ → 按类别聚合: {电子: 150万, 服装: 80万, 食品: 45万, ...}          │   │
│  │                                                                     │   │
│  │ Step 6: growth_calculate(current_month, previous_month)            │   │
│  │ → 计算增长率: {电子: +23%, 服装: +8%, 食品: +45%, ...}            │   │
│  │                                                                     │   │
│  │ Step 7: sort_by(growth_rates, "desc")                              │   │
│  │ → 排序结果: 食品(+45%) > 电子(+23%) > 服装(+8%) > ...             │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 6: 结果验证与输出                                             │   │
│  │                                                                     │   │
│  │ 元认知验证:                                                         │   │
│  │ • 逻辑一致性: ✓ 计算过程合理                                       │   │
│  │ • 结果合理性: ✓ 增长率在合理范围内                                 │   │
│  │ • 置信度: 0.92                                                      │   │
│  │                                                                     │   │
│  │ 生成响应:                                                           │   │
│  │ "根据分析，最近一个月增长最快的产品类别是:                         │   │
│  │  1. 食品类 (+45%) - 可能受节日促销影响                             │   │
│  │  2. 电子类 (+23%) - 新品发布带动                                   │   │
│  │  3. 服装类 (+8%) - 季节性增长                                      │   │
│  │  建议重点关注食品类的供应链准备。"                                 │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 7: 记忆沉淀 (后台)                                            │   │
│  │                                                                     │   │
│  │ L0 记录:                                                            │   │
│  │ • 完整对话日志                                                      │   │
│  │ • 工具调用记录                                                      │   │
│  │ • 执行时间和资源消耗                                                │   │
│  │                                                                     │   │
│  │ 触发巩固:                                                           │   │
│  │ • 提取: "用户关注销售增长分析"                                     │   │
│  │ • 提取: "食品类在节日期间增长显著"                                 │   │
│  │ • 更新用户画像: "增加数据分析偏好权重"                             │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Phase 8: 自我改进 (后台异步)                                        │   │
│  │                                                                     │   │
│  │ 性能分析:                                                           │   │
│  │ • 任务完成: ✓                                                       │   │
│  │ • 执行时间: 12秒 (可接受)                                          │   │
│  │ • 工具创建: 3个新工具                                               │   │
│  │                                                                     │   │
│  │ 改进识别:                                                           │   │
│  │ • csv_parse 工具可以优化为流式处理，减少内存占用                   │   │
│  │ • 可以预置数据分析相关工具，减少未来创建时间                       │   │
│  │                                                                     │   │
│  │ 改进应用:                                                           │   │
│  │ • 优化 csv_parse 工具代码                                          │   │
│  │ • 将数据分析工具标记为"常用"，提高优先级                          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```


---

## 安全与治理

### 8.1 安全架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Sanbot 安全架构                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   访问控制层                         │   │
│  │  • 用户身份认证                                      │   │
│  │  • 会话权限管理                                      │   │
│  │  • API 密钥保护                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   执行隔离层                         │   │
│  │  • 沙箱执行环境                                      │   │
│  │  • 资源限制 (CPU/内存/时间)                         │   │
│  │  • 网络访问控制                                      │   │
│  │  • 文件系统隔离                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   审批控制层                         │   │
│  │  • 敏感操作审批                                      │   │
│  │  • 新工具创建审核                                    │   │
│  │  • 高风险行动确认                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   审计追踪层                         │   │
│  │  • 完整操作日志                                      │   │
│  │  • 工具调用记录                                      │   │
│  │  • 改进历史追踪                                      │   │
│  │  • 异常事件告警                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 权限模型

```typescript
interface PermissionModel {
  // 权限层级
  levels: {
    read: [
      'memory_read',      // 读取记忆
      'file_read',        // 读取文件
      'web_fetch',        // 获取网页
      'config_read'       // 读取配置
    ],
    write: [
      'memory_write',     // 写入记忆
      'file_write',       // 写入文件
      'message_send',     // 发送消息
      'config_write'      // 修改配置
    ],
    execute: [
      'code_execute',     // 执行代码
      'tool_create',      // 创建工具
      'subagent_spawn',   // 创建子代理
      'system_command'    // 系统命令
    ],
    admin: [
      'permission_grant', // 授予权限
      'system_modify',    // 修改系统
      'security_override' // 安全覆盖
    ]
  }
  
  // 默认权限
  defaults: {
    newUser: ['read'],
    trustedUser: ['read', 'write'],
    powerUser: ['read', 'write', 'execute'],
    admin: ['read', 'write', 'execute', 'admin']
  }
  
  // 操作审批规则
  approvalRules: {
    always: [
      'file_delete',
      'system_command',
      'security_override'
    ],
    firstTime: [
      'tool_create',
      'subagent_spawn'
    ],
    highRisk: [
      'external_api_call',
      'credential_access'
    ]
  }
}
```

### 8.3 Self-Tooling 安全保障

```
┌─────────────────────────────────────────────────────────────┐
│              Self-Tooling 安全保障机制                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 代码生成阶段                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 禁止生成危险模式 (eval, exec, rm -rf, etc.)       │   │
│  │ • 限制可用的标准库和 API                            │   │
│  │ • 强制类型检查和边界检查                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  2. 静态分析阶段                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • AST 分析检测危险调用                              │   │
│  │ • 数据流分析检测信息泄露                            │   │
│  │ • 依赖检查确保无恶意包                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  3. 沙箱执行阶段                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • isolated-vm 隔离执行                              │   │
│  │ • 30秒超时限制                                      │   │
│  │ • 128MB 内存限制                                    │   │
│  │ • 禁止网络访问                                      │   │
│  │ • 只读文件系统 (除指定目录)                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  4. 人工审核阶段                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 新工具默认需要用户确认                            │   │
│  │ • 显示工具代码和功能说明                            │   │
│  │ • 用户可选择信任/拒绝/修改                          │   │
│  │ • 可配置自动信任规则                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  5. 运行时监控                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 实时资源使用监控                                  │   │
│  │ • 异常行为检测                                      │   │
│  │ • 自动熔断机制                                      │   │
│  │ • 完整审计日志                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 8.4 自我改进安全约束

```typescript
interface SelfImprovementConstraints {
  // 不可修改的核心
  immutable: [
    'security_policies',      // 安全策略
    'permission_model',       // 权限模型
    'audit_logging',          // 审计日志
    'human_oversight',        // 人工监督
    'core_objectives'         // 核心目标
  ]
  
  // 需要审批的修改
  requiresApproval: [
    'reasoning_strategy',     // 推理策略
    'tool_selection_logic',   // 工具选择逻辑
    'memory_consolidation',   // 记忆巩固规则
    'context_management'      // 上下文管理
  ]
  
  // 可自主修改的
  autonomous: [
    'prompt_templates',       // 提示词模板
    'output_formatting',      // 输出格式
    'tool_parameters',        // 工具参数默认值
    'recall_thresholds'       // 召回阈值
  ]
  
  // 回滚机制
  rollback: {
    enabled: true,
    maxHistory: 10,           // 保留最近10个版本
    autoRollbackOn: [
      'performance_degradation > 20%',
      'error_rate > 5%',
      'user_negative_feedback'
    ]
  }
}
```

---

## 预期效果与成功指标

### 9.1 核心能力预期

```
┌─────────────────────────────────────────────────────────────┐
│                    Sanbot 核心能力预期                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  能力维度              预期表现                目标指标     │
│  ─────────────────────────────────────────────────────────  │
│                                                             │
│  自主问题解决          无需用户微观管理        任务完成率   │
│                        自动识别并填补能力缺口  >80%         │
│                        智能错误恢复                         │
│                                                             │
│  记忆与个性化          记住用户偏好和历史      用户识别率   │
│                        提供个性化建议          >95%         │
│                        建立持续信任关系                     │
│                                                             │
│  工具创建              动态生成所需工具        工具创建     │
│                        工具质量可靠            成功率 >70%  │
│                        工具可复用                           │
│                                                             │
│  自我改进              持续优化性能            性能提升     │
│                        从错误中学习            >10%/月      │
│                        适应用户习惯                         │
│                                                             │
│  可信推理              推理过程可解释          置信度校准   │
│                        结果可验证              误差 <10%    │
│                        自我纠错                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 9.2 用户体验预期

```
┌─────────────────────────────────────────────────────────────┐
│                    用户体验预期                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  场景1: 首次使用                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 用户: "帮我整理一下桌面上的文件"                    │   │
│  │                                                     │   │
│  │ Sanbot:                                             │   │
│  │ • 自动识别桌面路径                                  │   │
│  │ • 分析文件类型和命名模式                            │   │
│  │ • 提出整理方案并请求确认                            │   │
│  │ • 执行整理并报告结果                                │   │
│  │ • 记住用户的整理偏好                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  场景2: 持续使用 (一周后)                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 用户: "整理一下"                                    │   │
│  │                                                     │   │
│  │ Sanbot:                                             │   │
│  │ • 回忆上次整理偏好                                  │   │
│  │ • 直接按偏好执行                                    │   │
│  │ • 报告: "已按您喜欢的方式整理完成"                 │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  场景3: 复杂任务                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 用户: "帮我分析竞品的定价策略"                      │   │
│  │                                                     │   │
│  │ Sanbot:                                             │   │
│  │ • 识别需要网络搜索能力                              │   │
│  │ • 创建竞品数据抓取工具                              │   │
│  │ • 创建价格分析工具                                  │   │
│  │ • 执行分析并生成报告                                │   │
│  │ • 保存工具供未来使用                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  场景4: 错误恢复                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 用户: "发送邮件给张三"                              │   │
│  │                                                     │   │
│  │ Sanbot:                                             │   │
│  │ • 尝试发送 → 失败 (邮箱地址无效)                   │   │
│  │ • 自动搜索记忆中张三的其他联系方式                  │   │
│  │ • 找到备用邮箱，请求确认                            │   │
│  │ • 用户确认后成功发送                                │   │
│  │ • 更新张三的联系信息                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 9.3 量化成功指标

| 指标类别 | 具体指标 | 目标值 | 测量方式 |
|---------|---------|--------|---------|
| **任务完成** | 任务完成率 | >80% | 用户反馈 + 自动评估 |
| | 首次成功率 | >60% | 无需重试的任务比例 |
| | 平均完成时间 | <30秒 | 简单任务响应时间 |
| **工具创建** | 工具创建成功率 | >70% | 验证通过率 |
| | 工具复用率 | >40% | 创建后被再次使用的比例 |
| | 工具质量评分 | >4.0/5.0 | 用户评分 |
| **记忆系统** | 记忆召回准确率 | >85% | 相关性评分 |
| | 用户识别率 | >95% | 正确识别回访用户 |
| | 个性化满意度 | >4.0/5.0 | 用户评分 |
| **自我改进** | 月度性能提升 | >10% | A/B 测试 |
| | 错误率下降 | >5%/月 | 错误日志分析 |
| | 用户满意度提升 | >5%/月 | NPS 评分 |
| **安全合规** | 安全事件数 | 0 | 安全审计 |
| | 审批响应时间 | <5秒 | 用户等待时间 |
| | 回滚成功率 | 100% | 回滚测试 |


---

## 实施路线图

### 10.1 分阶段实施计划

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Sanbot 实施路线图                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Phase 1: 基础设施层 (第1-4周)                                              │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 搭建稳定可靠的底层支撑                                        │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ Session Manager (会话管理)                                        │   │
│  │ □ Concurrency Controller (Lane System)                              │   │
│  │ □ Failover Manager (四级容错)                                       │   │
│  │ □ Basic Tool Registry (基础工具注册)                                │   │
│  │                                                                     │   │
│  │ 里程碑: 可运行的基础 Agent 框架                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Phase 2: 认知层 - 记忆系统 (第5-8周)                                       │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 实现完整的三层记忆架构                                        │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ L0/L1/L2 三层记忆存储                                            │   │
│  │ □ Hybrid Search (BM25 + Vector + RRF)                              │   │
│  │ □ 三种召回时机实现                                                  │   │
│  │ □ 记忆巩固机制                                                      │   │
│  │                                                                     │   │
│  │ 里程碑: Agent 能够"记住"用户                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Phase 3: 认知层 - 推理与上下文 (第9-12周)                                  │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 实现智能推理和上下文管理                                      │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ Reasoning Engine (多种推理模式)                                   │   │
│  │ □ Context Reduction (上下文精简)                                    │   │
│  │ □ Context Offloading (上下文卸载)                                   │   │
│  │ □ Context Isolation (上下文隔离)                                    │   │
│  │                                                                     │   │
│  │ 里程碑: Agent 能够处理复杂长任务                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Phase 4: 自主层 - Self-Tooling (第13-18周)                                 │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 实现动态工具创建能力                                          │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ 能力缺口分析器                                                    │   │
│  │ □ 工具代码生成器                                                    │   │
│  │ □ 工具验证沙箱                                                      │   │
│  │ □ 工具注册与沉淀机制                                                │   │
│  │ □ 安全审核流程                                                      │   │
│  │                                                                     │   │
│  │ 里程碑: Agent 能够创建自己需要的工具                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Phase 5: 自主层 - 元认知 (第19-22周)                                       │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 实现自我反思和纠错能力                                        │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ 推理质量监控器                                                    │   │
│  │ □ 置信度评估器                                                      │   │
│  │ □ 偏见检测器                                                        │   │
│  │ □ 自我纠正机制                                                      │   │
│  │                                                                     │   │
│  │ 里程碑: Agent 能够反思和纠正自己的推理                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Phase 6: 自主层 - 自我改进 (第23-28周)                                     │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 实现持续自我优化能力                                          │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ 性能监控系统                                                      │   │
│  │ □ 改进机会识别器                                                    │   │
│  │ □ 改进验证沙箱                                                      │   │
│  │ □ 安全回滚机制                                                      │   │
│  │                                                                     │   │
│  │ 里程碑: Agent 能够持续优化自身                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Phase 7: 集成与优化 (第29-32周)                                            │
│  ══════════════════════════════════════════════════════════════════════    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 目标: 全系统集成和生产就绪                                          │   │
│  │                                                                     │   │
│  │ 交付物:                                                             │   │
│  │ □ 全系统集成测试                                                    │   │
│  │ □ 性能优化                                                          │   │
│  │ □ 安全审计                                                          │   │
│  │ □ 文档完善                                                          │   │
│  │ □ 用户界面优化                                                      │   │
│  │                                                                     │   │
│  │ 里程碑: 生产就绪的 Sanbot v1.0                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.2 技术栈选型

| 组件 | 推荐选择 | 理由 |
|------|---------|------|
| **运行时** | Node.js 22+ / Bun | TypeScript ESM 原生支持，性能优秀 |
| **向量数据库** | SQLite + sqlite-vec | 轻量、零配置、本地优先 |
| **全文检索** | SQLite FTS5 | 内置、无需额外依赖 |
| **LLM 调用** | Vercel AI SDK | 标准化接口、流式支持、多模型 |
| **代码执行沙箱** | isolated-vm | 安全隔离、资源限制 |
| **配置管理** | Zod / TypeBox | 类型安全、运行时校验 |
| **并发控制** | p-queue | 成熟的并发抽象 |
| **任务调度** | node-cron | 灵活的定时任务 |
| **日志系统** | pino | 高性能、结构化日志 |
| **测试框架** | Vitest | 快速、TypeScript 原生 |

### 10.3 MVP 功能清单

**必须有 (Must Have) - Phase 1-3**:
- [x] 基础对话能力
- [x] 会话隔离与持久化
- [x] 三层记忆架构
- [x] 基础工具调用
- [x] 多级容错
- [x] 三种召回时机
- [x] 上下文精简

**应该有 (Should Have) - Phase 4-5**:
- [ ] 基础 Self-Tooling
- [ ] 推理监控
- [ ] 置信度评估
- [ ] 基础自我纠正

**可以有 (Could Have) - Phase 6-7**:
- [ ] 完整 Self-Tooling
- [ ] 自我改进
- [ ] CodeAct 执行
- [ ] 多渠道接入

**未来考虑 (Won't Have Now)**:
- [ ] 多 Agent 协作
- [ ] 语音交互
- [ ] 多模态能力
- [ ] 企业级权限管理

### 10.4 风险与缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| **Self-Tooling 安全风险** | 高 | 中 | 沙箱隔离 + 人工审核 + 权限控制 |
| **自我改进失控** | 高 | 低 | 改进验证 + 回滚机制 + 核心目标锁定 |
| **记忆系统性能** | 中 | 中 | 增量索引 + 缓存 + 异步处理 |
| **上下文溢出** | 中 | 高 | 上下文工程 + 动态压缩 |
| **LLM 成本** | 中 | 高 | 模型选择策略 + 缓存 + 批处理 |
| **用户隐私** | 高 | 低 | 本地存储 + 加密 + 最小权限 |


---

## 结语

### 愿景重申

Sanbot 的诞生源于一个简单而深刻的愿景：

> **"它自己思考、自己搜索、自己写工具、然后自己完成任务。它还能记住用户，建立持续的信任关系。"**

这不是科幻，而是基于当前技术可实现的目标。通过本文档描述的三层架构设计，Sanbot 将实现：

### 核心价值

```
┌─────────────────────────────────────────────────────────────┐
│                    Sanbot 核心价值                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  对用户:                                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 真正的助理体验，而非问答机器                       │   │
│  │ • 越用越懂你，建立持续信任                           │   │
│  │ • 解决问题，而非等待指令                             │   │
│  │ • 数据本地存储，隐私有保障                           │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  对技术:                                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 从 Prompt Engineering 到 Context Engineering      │   │
│  │ • 从静态工具到动态工具创建                           │   │
│  │ • 从被动响应到自主问题解决                           │   │
│  │ • 从固定能力到持续进化                               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  对行业:                                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 探索 Agent 自主性的边界                            │   │
│  │ • 验证 Self-Tooling 的可行性                         │   │
│  │ • 实践递归自我改进的安全框架                         │   │
│  │ • 推动本地优先 AI 的发展                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 哲学回归

回到 Sanbot 名字的由来——"道生一，一生二，二生三，三生万物"：

- **道 (Tao)**：用户的需求，是一切的起点
- **一 (基础设施层)**：稳定可靠的根基
- **二 (认知层)**：记忆与推理的二元能力
- **三 (自主层)**：Self-Tooling、Self-Improvement、Meta-Cognition
- **万物**：从三层架构衍生出解决万千问题的能力

Sanbot 不仅是一个技术项目，更是对"智能"本质的探索。我们相信，真正的智能不在于知道多少，而在于：

- **能够学习**：从经验中成长
- **能够创造**：突破预设的边界
- **能够反思**：认识自己的局限
- **能够记忆**：建立持续的关系

### 下一步

本架构设计文档为 Sanbot 的开发提供了蓝图。接下来的工作包括：

1. **技术验证**：对关键技术点进行原型验证
2. **详细设计**：为每个组件编写详细设计文档
3. **开发启动**：按照路线图开始 Phase 1 开发
4. **持续迭代**：根据实践反馈调整设计

---

**"三生万物"——让我们开始创造。**

---

## 附录

### A. 参考资料

#### 学术论文
- Self-Tooling Agent (ICLR 2026)
- Gödel Agent: Recursive Self-Improvement
- Context Engineering for AI Agents
- Memory Consolidation in Neural Networks

#### 技术博客
- Anthropic: Building Effective Agents
- LangChain: Choosing the Right Multi-Agent Architecture
- Manus: CodeAct Execution Paradigm

#### 开源项目
- OpenClaw: https://github.com/openclaw/openclaw
- Universal Memory MCP: 本地项目

### B. 术语表

| 术语 | 定义 |
|------|------|
| **Self-Tooling** | Agent 动态创建工具的能力 |
| **Meta-Cognition** | 对自身认知过程的认知，"思考如何思考" |
| **Context Engineering** | 将上下文视为核心架构原语的设计方法 |
| **CodeAct** | 用代码替代 JSON 工具调用的执行范式 |
| **Memory Consolidation** | 将短期记忆转化为长期记忆的过程 |
| **Hybrid Search** | 结合向量检索和关键词检索的混合搜索 |
| **RRF** | Reciprocal Rank Fusion，一种结果融合算法 |
| **Lane System** | 基于泳道的并发控制机制 |

### C. 版本历史

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|---------|
| v1.0 | 2026-02-02 | Claude Opus 4.5 | 初始版本 |

---

**文档结束**

