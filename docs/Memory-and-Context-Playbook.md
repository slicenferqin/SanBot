# SanBot 记忆与上下文策略手册

## 目标
在不牺牲响应速度的前提下，让 SanBot 在每次任务中拿到“刚好够用”的上下文：
- 先做结构化检索（agentic search），再补语义记忆。
- 控制 token 成本，避免上下文过载。
- 为 Gather → Act → Verify 提供稳定输入。

关联代码：`src/memory/storage.ts`、`src/memory/retrieval.ts`、`src/memory/consolidator.ts`、`src/agent.ts`。

## 记忆分层模型

### L0：原始对话日志（事实来源）
- 存储位置：`~/.sanbot/memory/daily/YYYY-MM-DD.jsonl`。
- 写入时机：每轮对话结束后记录用户输入和助手输出。
- 作用：保留完整上下文，可追溯，不直接大规模注入 prompt。

### L1：抽取记忆（结构化片段）
- 存储位置：`~/.sanbot/memory/extracted/*.md`。
- 分类：`preference`、`fact`、`decision`、`profile`。
- 作用：压缩高价值信息，供后续聚合与检索。

### L2：主摘要（长期画像）
- 存储位置：`~/.sanbot/memory/summary/master.md`。
- 内容：用户画像、偏好、关键事实、近期决策。
- 作用：会话启动时提供稳定、低成本背景。

## 上下文构建流程（推荐）

### 第 1 步：Agentic Search（优先）
先从任务工作区获取“当前任务真相”，包括：
1. 目录结构与关键文件（`glob`）。
2. 目标关键词与实现位置（`grep`）。
3. 必要文件内容（`read`）。

原则：先找结构化证据，再调用记忆层，避免旧记忆污染当前任务。

### 第 2 步：注入 L2 + 最近会话
当前实现会读取 L2 摘要与最近对话（`src/memory/retrieval.ts`），作为系统提示补充。

建议注入顺序：
1. L2 摘要（短、稳定）。
2. 最近 N 轮会话（默认 20，按任务可缩减）。
3. 必要时再追加 L1 分类片段。

### 第 3 步：动态补充（按需）
出现以下情况再增量补充上下文：
- 用户追问历史决策原因。
- 多文档交叉分析。
- 长任务中切换子问题。

可引入“子代理检索”做并行 gather，主代理只接收摘要结果。

## Compact 策略（防上下文膨胀）
每轮结束后执行轻量整理，遵循：
1. 保留“结论、约束、下一步”。
2. 删除重复推理与中间噪声。
3. 工具输出仅保留关键片段（路径、状态、错误摘要）。

建议阈值：
- 当会话消息超过 40 条或 prompt 长度逼近上限时，触发 compact。
- compact 结果写入会话态摘要，不覆盖原始 L0 数据。

## 巩固计划（Consolidation）
当前整理流程通过命令触发（`sanbot consolidate`）。

建议升级为自动调度：
1. 每日低峰执行 L0 → L1 抽取。
2. 每周执行 L1 → L2 综合摘要。
3. 失败重试并写入审计日志。

最低可行方案：
- 先做“启动时检查”：若超过 24h 未整理，后台提示用户是否执行。

## 检索策略（下一阶段）

### 当前
- 基于文件与最近对话的显式检索。
- 优点：可解释、稳定、成本低。

### 下一步
- 加入语义索引（SQLite FTS / 向量库）用于跨时段召回。
- 保持混合检索：关键词过滤 + 语义排序。
- 输出时附来源（时间、文件、会话），保证可追溯。

## 验证指标（Verify）
记忆与上下文策略至少跟踪以下指标：
1. **上下文命中率**：回答中引用到有效历史信息的比例。
2. **误召回率**：引入错误/过时记忆导致偏差的比例。
3. **Token 成本**：平均每轮上下文长度。
4. **用户纠正次数**：用户因上下文错误而二次澄清的频次。

## 今日可落地动作
1. 在 WebUI 设置中显示“当前注入上下文摘要（L2 + recent）”。
2. 为 `consolidate` 增加状态输出：处理日期数、抽取条数、失败原因。
3. 建立 `docs/memory-examples/`，存放 2-3 组标准样例，便于回归验证。
